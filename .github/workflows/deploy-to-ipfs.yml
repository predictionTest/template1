name: Deploy to IPFS via Pinata CAR

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual triggers

permissions:
  contents: read
  pull-requests: write
  statuses: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build project
      env:
        VITE_ORACLE_CONTRACT_ADDRESS: ${{ secrets.VITE_ORACLE_CONTRACT_ADDRESS }}
        MARKET_FACTORY_CONTRACT_ADDRESS: ${{ secrets.MARKET_FACTORY_CONTRACT_ADDRESS }}
        VITE_SCAN_FUTURE_EPOCHS: ${{ secrets.VITE_SCAN_FUTURE_EPOCHS }}
        VITE_CHUNK_SIZE: ${{ secrets.VITE_CHUNK_SIZE }}
      run: npm run build

    - name: Install deployment tools
      run: |
        npm install -g ipfs-car
        npm install pinata@latest

    - name: Create CAR file
      id: create-car
      run: |
        mkdir -p .temp
        npx ipfs-car pack dist --output .temp/build.car --wrap
        ROOT_CID=$(npx ipfs-car roots .temp/build.car)
        echo "root_cid=$ROOT_CID" >> $GITHUB_OUTPUT
        echo "üìç Root CID: $ROOT_CID"

    - name: Upload to Pinata
      id: upload
      env:
        PINATA_JWT: ${{ secrets.PINATA_JWT }}
      run: |
        node -e "
        import { PinataSDK } from 'pinata';
        import fs from 'fs';
        import { IPFS_GATEWAYS } from './constants.js';
        
        (async () => {
          try {
            const pinata = new PinataSDK({ pinataJwt: process.env.PINATA_JWT });
            await pinata.testAuthentication();
            console.log('‚úÖ Pinata authentication successful');
            
            const carBuffer = fs.readFileSync('.temp/build.car');
            const carBlob = new Blob([carBuffer], { type: 'application/vnd.ipld.car' });
            const carFile = new File([carBlob], 'build.car', { type: 'application/vnd.ipld.car' });
            
            const upload = await pinata.upload.public
              .file(carFile)
              .name('GitHub Actions Deploy - ${{ github.sha }}')
              .car();
            
            const rootCid = '${{ steps.create-car.outputs.root_cid }}';
            
            console.log('‚úÖ Upload successful!');
            console.log('üìç Pinata File ID:', upload.id);
            console.log('üìç IPFS CID:', upload.cid);
            console.log('üìç Root CID:', rootCid);
            
            // Write file ID to output for webhook
            fs.appendFileSync(process.env.GITHUB_OUTPUT, \`pinata_file_id=\${upload.id}\\n\`);
            
            // CID-based subdomain gateway URL
            const cidGatewayUrl = \`https://\${rootCid}.ipfs.\${IPFS_GATEWAYS.DWEB}/\`;
            console.log('üåç CID Gateway URL:', cidGatewayUrl);
            
            // Path-based gateway URL
            const pathGatewayUrl = \`https://\${IPFS_GATEWAYS.DWEB}/ipfs/\${rootCid}\`;
            
            fs.writeFileSync(process.env.GITHUB_STEP_SUMMARY, 
              '# üéâ IPFS Deployment Successful!\\n\\n' +
              '| Property | Value |\\n' +
              '|----------|-------|\\n' +
              '| Root CID | \`' + rootCid + '\` |\\n' +
              '| CAR CID | \`' + upload.cid + '\` |\\n' +
              '| CID Gateway | [' + rootCid + '.ipfs.dweb.link](' + cidGatewayUrl + ') |\\n' +
              '| Path Gateway | [dweb.link](' + pathGatewayUrl + ') |\\n' +
              '\\n‚úÖ *Your website is live on IPFS!*\\n'
            );
            
          } catch (error) {
            console.error('‚ùå Deployment failed:', error.message);
            process.exit(1);
          }
        })();
        "

    - name: Notify AWS Lambda Webhook
      env:
        WEBHOOK_URL: ${{ secrets.AWS_WEBHOOK_URL }}
        WEBHOOK_SECRET: ${{ secrets.WEBHOOK_GITHUB_SECRET }}
        ROOT_CID: ${{ steps.create-car.outputs.root_cid }}
        PINATA_FILE_ID: ${{ steps.upload.outputs.pinata_file_id }}
      run: |
        echo "üîî Sending deployment notification to webhook..."
        
        if [ -z "$WEBHOOK_URL" ]; then
          echo "‚ö†Ô∏è  AWS_WEBHOOK_URL secret not set, skipping webhook notification"
          exit 0
        fi
        
        if [ -z "$WEBHOOK_SECRET" ]; then
          echo "‚ö†Ô∏è  WEBHOOK_GITHUB_SECRET secret not set, skipping webhook notification"
          exit 0
        fi
        
        echo "üìç CID: $ROOT_CID"
        echo "üìç Pinata File ID: $PINATA_FILE_ID"
        echo "üìç Commit: ${{ github.sha }}"
        echo "üìç Repository: ${{ github.repository }}"
        
        # Create webhook payload using jq (ensures proper JSON formatting)
        PAYLOAD=$(jq -n \
          --arg repo "https://github.com/${{ github.repository }}" \
          --arg cid "$ROOT_CID" \
          --arg commit "${{ github.sha }}" \
          --arg fileId "$PINATA_FILE_ID" \
          '{githubRepo: $repo, cid: $cid, commitSha: $commit, pinataFileId: $fileId}')
        
        echo "üì¶ Payload: $PAYLOAD"
        
        # Generate GitHub webhook signature (HMAC-SHA256)
        SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | sed 's/^.* //')
        
        echo "üîê Signature generated"
        
        # Send webhook notification with signature
        RESPONSE=$(curl -s -X POST "$WEBHOOK_URL" \
          -H "Content-Type: application/json" \
          -H "X-Hub-Signature-256: sha256=$SIGNATURE" \
          --data "$PAYLOAD")
        
        echo ""
        echo "üì¨ Webhook Response:"
        echo "$RESPONSE" | jq '.' || echo "$RESPONSE"
        
        # Check if webhook was successful
        SUCCESS=$(echo "$RESPONSE" | jq -r '.success // false')
        
        if [ "$SUCCESS" = "true" ]; then
          echo "‚úÖ Webhook notification sent successfully!"
        else
          echo "‚ö†Ô∏è  Webhook notification may have failed"
          echo "Response: $RESPONSE"
        fi

    - name: Cleanup
      if: always()
      run: rm -rf .temp
